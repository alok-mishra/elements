<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Element Flashcards</title>
    <style>
        :root {
            --bg1: #001f3f;
            --bg2: #005f73;
            --bg3: #0a9396;
            --btn: #00d4ff;
            --btn-hover: #00b0d6;
            --card-w: 340px;
            --card-h: 204px; /* 1.666 aspect ratio */
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: "Poppins", sans-serif;
            background: linear-gradient(135deg, var(--bg1), var(--bg2), var(--bg3));
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* top-start layout so title isn't cropped */
            min-height: 100vh; /* let browser manage address-bar changes */
            margin: 0;
            padding: calc(16px + env(safe-area-inset-top, 0px)) 16px 16px calc(16px + env(safe-area-inset-left, 0px));
            box-sizing: border-box;
        }

        h1 {
            margin: 0 0 12px 0;
            font-size: 1.6rem;
            text-align: center;
        }

        /* Make viewport slightly larger so the rotating card doesn't get clipped.
           Keep visual spacing so faces won't overlap the controls when overflow is visible. */
        .flashcard {
            width: var(--card-w);
            height: var(--card-h);
            perspective: 1000px;

            /* allow rotated edges to show */
            overflow: visible;

            /* give a small buffer around the card so shadows / edges don't touch controls */
            margin-bottom: 28px;
            padding: 6px;
            box-sizing: content-box;
            touch-action: pan-y;
        }

        /* keep the inner element slightly bigger than the face so rotation won't clip */
        .card-inner {
            position: relative;
            width: calc(100% + 12px);   /* account for the flashcard padding */
            height: calc(100% + 12px);
            left: -6px;                 /* re-center because of the increased size */
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 10px;
            will-change: transform;      /* hint for smoother animation on mobile */
            box-sizing: border-box;
        }

        /* ensure faces still match the inner element and don't grow beyond it */
        .card-face {
            box-sizing: border-box;
            overflow: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 10px;

            /* prevent the mirrored/backwards content from showing through */
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;

            /* ensure proper 3D rendering on mobile */
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;

            /* promote to its own layer to avoid bleeding during the rotate */
            transform: translateZ(0);

            background: rgba(255, 255, 255, 0.12);
            border: 2px solid rgba(255, 255, 255, 0.22);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 2.2rem; /* base size for symbol */
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
            -webkit-user-select: none;
            user-select: none;
        }

        /* explicitly define front face transform */
        .card-front {
            -webkit-transform: rotateY(0deg);
            transform: rotateY(0deg);
        }

        /* back face: same large font as symbol and vendor-prefix transform */
        .card-back {
            -webkit-transform: rotateY(180deg);
            transform: rotateY(180deg);
            font-size: 2.2rem; /* match the symbol size */
            padding: 8px 12px;
            text-align: center;
            line-height: 1.05;
        }

        .card-inner.flipped {
            transform: rotateY(180deg);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 6px;
            margin-bottom: 8px;
        }

        button {
            background: var(--btn);
            border: none;
            color: #000;
            font-size: 1rem;
            padding: 12px 18px; /* slightly larger tappable area */
            border-radius: 8px;
            cursor: pointer;
            transition: 0.18s;
            min-width: 72px;
            touch-action: manipulation; /* improve touch responsiveness */
        }

        button:hover {
            background: var(--btn-hover);
        }

        .legend {
            margin-top: 8px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.92);
            text-align: center;
            background: rgba(0,0,0,0.12);
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 720px;
            line-height: 1.3;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 480px) {
            :root {
                --card-w: min(90vw, 380px);
                --card-h: calc(var(--card-w) * 0.6);
            }

            h1 { font-size: 1.2rem; }

            .card-face { font-size: 1.6rem; }
            .card-back { font-size: 1rem; padding: 8px; }

            button {
                padding: 14px 16px;
                min-width: 64px;
                font-size: 1rem;
            }

            .legend {
                font-size: 0.9rem;
                padding: 10px;
            }
        }

        /* Larger screens */
        @media (min-width: 900px) {
            .card-face { font-size: 2.6rem; }
            .card-back { font-size: 1.4rem; }
        }

        /* New styles for card wrapper and side buttons */
        .card-wrap {
            width: 100%;
            max-width: calc(var(--card-w) + 160px);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding-inline: calc(12px + env(safe-area-inset-left, 0px));
            padding-inline-end: calc(12px + env(safe-area-inset-right, 0px));
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        /* side buttons: absolutely positioned over the card so they don't expand layout or get pushed off screen */
        .side-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 30;
            pointer-events: auto;

            font-family: Impact, Haettenschweiler, "Arial Black", sans-serif;
            font-weight: 900;
            letter-spacing: 0.5px;
            font-size: 2.4rem;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;

            background: rgba(255,255,255,0.12);
            border: 2px solid rgba(255,255,255,0.22);
            color: #fff;

            width: 72px;
            height: calc(var(--card-h) - 12px);
            border-radius: 10px;

            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            transition: transform 0.12s, background 0.12s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        /* position specific sides */
        .side-btn.left  { left: 8px;  } /* inside wrapper padding so safe-area won't cut it off */
        .side-btn.right { right: 8px; }

        /* responsive shrink and keep text readable */
        @media (max-width: 480px) {
            .side-btn { width: 56px; height: calc(var(--card-h) * 0.78); font-size: 2rem; }
            .card-face { font-size: 1.9rem; }       /* keep names large in portrait */
            .card-back  { font-size: 1.9rem; padding: 8px 12px; }
            .card-wrap  { padding-inline: calc(8px + env(safe-area-inset-left, 0px)); padding-inline-end: calc(8px + env(safe-area-inset-right, 0px)); }
        }
    </style>
</head>

<body>
    <h1>Element Flashcards</h1>

    <!-- replace the single .flashcard block with this wrapper that includes side arrows -->
    <div class="card-wrap">
        <button class="side-btn left" id="sidePrev" aria-label="Previous">&lt;</button>

        <div class="flashcard" id="flashcard" role="button" aria-label="Element flashcard">
            <div class="card-inner" id="card-inner">
                <div class="card-face card-front" id="card-front"></div>
                <div class="card-face card-back" id="card-back"></div>
            </div>
        </div>

        <button class="side-btn right" id="sideNext" aria-label="Next">&gt;</button>
    </div>

    <div class="controls">
        <button id="prevBtn" aria-label="Previous">‚¨ÖÔ∏è Prev</button>
        <button id="shuffleBtn" aria-label="Shuffle">üîÄ Shuffle</button>
        <button id="flipBtn" aria-label="Flip">üîÅ Flip</button>
        <button id="nextBtn" aria-label="Next">‚û°Ô∏è Next</button>
        </div>

        <div class="legend" id="legend" aria-hidden="false">
            Keyboard: Space = Flip ¬∑ ‚Üê = Prev ¬∑ ‚Üí = Next ¬∑ Shuffle = randomize deck<br />
            Mobile: Tap card = Flip ¬∑ Swipe left/right = Next/Prev ¬∑ Tap Shuffle to shuffle
    </div>

    <script>
        const elements = [
            { sym: "H", name: "Hydrogen" },
            { sym: "He", name: "Helium" },
            { sym: "Li", name: "Lithium" },
            { sym: "Be", name: "Beryllium" },
            { sym: "B", name: "Boron" },
            { sym: "C", name: "Carbon" },
            { sym: "N", name: "Nitrogen" },
            { sym: "O", name: "Oxygen" },
            { sym: "F", name: "Fluorine" },
            { sym: "Ne", name: "Neon" },
            { sym: "Na", name: "Sodium" },
            { sym: "Mg", name: "Magnesium" },
            { sym: "Al", name: "Aluminum" },
            { sym: "Si", name: "Silicon" },
            { sym: "P", name: "Phosphorus" },
            { sym: "S", name: "Sulfur" },
            { sym: "Cl", name: "Chlorine" },
            { sym: "Ar", name: "Argon" },
            { sym: "K", name: "Potassium" },
            { sym: "Ca", name: "Calcium" },
            { sym: "Sc", name: "Scandium" },
            { sym: "Ti", name: "Titanium" },
            { sym: "V", name: "Vanadium" },
            { sym: "Cr", name: "Chromium" },
            { sym: "Mn", name: "Manganese" },
            { sym: "Fe", name: "Iron" },
            { sym: "Co", name: "Cobalt" },
            { sym: "Ni", name: "Nickel" },
            { sym: "Cu", name: "Copper" },
            { sym: "Zn", name: "Zinc" },
            { sym: "Ga", name: "Gallium" },
            { sym: "Ge", name: "Germanium" },
            { sym: "As", name: "Arsenic" },
            { sym: "Se", name: "Selenium" },
            { sym: "Br", name: "Bromine" },
            { sym: "Kr", name: "Krypton" },
            { sym: "Ag", name: "Silver" },
            { sym: "Sn", name: "Tin" },
            { sym: "I", name: "Iodine" },
            { sym: "Xe", name: "Xenon" },
            { sym: "W", name: "Tungsten" },
            { sym: "Au", name: "Gold" },
            { sym: "Hg", name: "Mercury" },
            { sym: "Pb", name: "Lead" },
            { sym: "Bi", name: "Bismuth" },
            { sym: "Rn", name: "Radon" },
            { sym: "Ra", name: "Radium" },
            { sym: "U", name: "Uranium" },
            { sym: "Pu", name: "Plutonium" },
            { sym: "Cm", name: "Curium" },
            { sym: "Es", name: "Einsteinium" },
            { sym: "Md", name: "Mendelevium" }
        ];

            // deck holds the current order. start ordered but pick a random starting index
            let deck = elements.slice();
            let current = Math.floor(Math.random() * deck.length);

        const front = document.getElementById("card-front");
        const back = document.getElementById("card-back");
        const inner = document.getElementById("card-inner");
            const flashcard = document.getElementById("flashcard");

        function updateCard() {
            const el = deck[current];
            front.textContent = el.sym;
            back.textContent = el.name;
        }

            function shuffleDeck() {
                // Fisher-Yates shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                current = 0; // show first card of shuffled deck
                updateCard();
            }

            function next() {
            current = (current + 1) % deck.length;
            updateCard();
        }

            function prev() {
            current = (current - 1 + deck.length) % deck.length;
            updateCard();
            }

            // Buttons
            document.getElementById("flipBtn").onclick = () => inner.classList.toggle("flipped");
            document.getElementById("nextBtn").onclick = next;
            document.getElementById("prevBtn").onclick = prev;
            document.getElementById("shuffleBtn").onclick = shuffleDeck;

            // Click on card toggles flip (desktop)
            let lastTouch = 0;
            flashcard.addEventListener("click", (e) => {
                // ignore synthetic click right after a touch event
                if (Date.now() - lastTouch < 400) return;
                inner.classList.toggle("flipped"); // tap -> flip
            });

            // Touch gestures for mobile: tap -> flip, swipe -> next/prev
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
            flashcard.addEventListener("touchstart", (e) => {
                if (e.touches.length !== 1) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
            }, { passive: true });

            flashcard.addEventListener("touchend", (e) => {
                lastTouch = Date.now();
                const t = e.changedTouches[0];
                const dx = t.clientX - touchStartX;
                const dy = t.clientY - touchStartY;
                const dt = Date.now() - touchStartTime;

                // horizontal swipe (fast or long enough)
                if (Math.abs(dx) > 50 && Math.abs(dx) > Math.abs(dy) && dt < 700) {
                    if (dx < 0) next(); else prev();
                    return;
                }

                // treat as tap if movement small
                if (Math.abs(dx) < 20 && Math.abs(dy) < 20 && dt < 500) {
                    inner.classList.toggle("flipped"); // touch tap -> flip
                }
            });

            // Keyboard controls: Space toggles flip, ArrowRight -> next, ArrowLeft -> prev
            document.addEventListener('keydown', (e) => {
            // when focus is on an input/textarea ignore
            const tag = (document.activeElement && document.activeElement.tagName) || '';
            if (tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable) return;

            if (e.code === 'Space') {
                e.preventDefault();
                inner.classList.toggle('flipped');
                return;
            }

            if (e.key === 'ArrowRight') {
                e.preventDefault();
                next();
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prev();
                return;
            }
        });

    // initial render
    updateCard();

    // hookup side arrow buttons (place after your existing button hookups)
    const sidePrev = document.getElementById('sidePrev');
    const sideNext = document.getElementById('sideNext');
    if (sidePrev) sidePrev.addEventListener('click', (e) => { e.preventDefault(); prev(); });
    if (sideNext) sideNext.addEventListener('click', (e) => { e.preventDefault(); next(); });
    </script>
</body>

</html>
